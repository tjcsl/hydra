//Automaticly generated by gen_hydrapacket.py
#include <arpa/inet.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include "hydrapacket.h"
int hydra_read_RUN(int fd,uint32_t *jobid) {
    int i; uint16_t u16; uint32_t u32;

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *jobid = u32;
   return 0;
}
int hydra_write_RUN(int fd,uint32_t  jobid) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 13;
    if (write(fd, &type, 1) != 1) {return -1;}

    u32 = jobid; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    return 0;
}
int hydra_read_JOBDONEACK(int fd,uint32_t *jobid) {
    int i; uint16_t u16; uint32_t u32;

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *jobid = u32;
   return 0;
}
int hydra_write_JOBDONEACK(int fd,uint32_t  jobid) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 12;
    if (write(fd, &type, 1) != 1) {return -1;}

    u32 = jobid; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    return 0;
}
int hydra_read_EXEC(int fd,uint32_t *jobid) {
    int i; uint16_t u16; uint32_t u32;

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *jobid = u32;
   return 0;
}
int hydra_write_EXEC(int fd,uint32_t  jobid) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 6;
    if (write(fd, &type, 1) != 1) {return -1;}

    u32 = jobid; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    return 0;
}
int hydra_read_CHALLENGE(int fd,uint32_t *challenge_id) {
    int i; uint16_t u16; uint32_t u32;

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *challenge_id = u32;
   return 0;
}
int hydra_write_CHALLENGE(int fd,uint32_t  challenge_id) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 0;
    if (write(fd, &type, 1) != 1) {return -1;}

    u32 = challenge_id; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    return 0;
}
int hydra_read_CHOK(int fd,char *ok) {
    int i; uint16_t u16; uint32_t u32;
    if ((i = read(fd, ok, 1)) != 1) {return i;}
   return 0;
}
int hydra_write_CHOK(int fd,char  ok) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 2;
    if (write(fd, &type, 1) != 1) {return -1;}
    if ((i = write(fd, &ok, 1)) != 1) {return i;}
    return 0;
}
int hydra_read_PING(int fd) {
    int i; uint16_t u16; uint32_t u32;
   return 0;
}
int hydra_write_PING(int fd) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 3;
    if (write(fd, &type, 1) != 1) {return -1;}
    return 0;
}
int hydra_read_FILEACK(int fd,uint32_t *jobid) {
    int i; uint16_t u16; uint32_t u32;

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *jobid = u32;
   return 0;
}
int hydra_write_FILEACK(int fd,uint32_t  jobid) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 10;
    if (write(fd, &type, 1) != 1) {return -1;}

    u32 = jobid; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    return 0;
}
int hydra_read_SUBMIT(int fd,const void** exe_name_data,int *exe_name_len,uint16_t *slots,uint16_t *numfiles) {
    int i; uint16_t u16; uint32_t u32;
 
    if ((i = read(fd, exe_name_len, 4)) < 4) { 
        return i; 
    } 
    *exe_name_len = ntohl(*exe_name_len); 
    *exe_name_data = malloc(*exe_name_len); 
    if ((i = read(fd, exe_name_data, *exe_name_len)) != *exe_name_len) { 
        return i; 
    }

    if ((i = read(fd, &u16, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *slots = u16;

    if ((i = read(fd, &u16, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *numfiles = u16;
   return 0;
}
int hydra_write_SUBMIT(int fd,const void*  exe_name_data,int exe_name_len,uint16_t  slots,uint16_t  numfiles) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 5;
    if (write(fd, &type, 1) != 1) {return -1;}

    i = htonl(exe_name_len); 
    if ((i = write(fd, &i, 4)) != 4) {return i;} 
    if ((i = write(fd, exe_name_data, exe_name_len)) != exe_name_len) {return i;}

    u16 = slots; 
    u16 = htonl(u16);
    if ((i = write(fd, &u16, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}

    u16 = numfiles; 
    u16 = htonl(u16);
    if ((i = write(fd, &u16, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    return 0;
}
int hydra_read_RUNACK(int fd,uint32_t *jobid) {
    int i; uint16_t u16; uint32_t u32;

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *jobid = u32;
   return 0;
}
int hydra_write_RUNACK(int fd,uint32_t  jobid) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 14;
    if (write(fd, &type, 1) != 1) {return -1;}

    u32 = jobid; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    return 0;
}
int hydra_read_JOBDONE(int fd,uint32_t *jobid) {
    int i; uint16_t u16; uint32_t u32;

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *jobid = u32;
   return 0;
}
int hydra_write_JOBDONE(int fd,uint32_t  jobid) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 11;
    if (write(fd, &type, 1) != 1) {return -1;}

    u32 = jobid; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    return 0;
}
int hydra_read_JOBDATA(int fd,uint32_t *jobid) {
    int i; uint16_t u16; uint32_t u32;

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *jobid = u32;
   return 0;
}
int hydra_write_JOBDATA(int fd,uint32_t  jobid) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 8;
    if (write(fd, &type, 1) != 1) {return -1;}

    u32 = jobid; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    return 0;
}
int hydra_read_HEARTBEAT(int fd,uint16_t *slots,const void** hostname_data,int *hostname_len,uint32_t *mb_free,uint32_t *mb_ram,uint32_t *load_avg) {
    int i; uint16_t u16; uint32_t u32;

    if ((i = read(fd, &u16, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *slots = u16;
 
    if ((i = read(fd, hostname_len, 4)) < 4) { 
        return i; 
    } 
    *hostname_len = ntohl(*hostname_len); 
    *hostname_data = malloc(*hostname_len); 
    if ((i = read(fd, hostname_data, *hostname_len)) != *hostname_len) { 
        return i; 
    }

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *mb_free = u32;

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *mb_ram = u32;

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *load_avg = u32;
   return 0;
}
int hydra_write_HEARTBEAT(int fd,uint16_t  slots,const void*  hostname_data,int hostname_len,uint32_t  mb_free,uint32_t  mb_ram,uint32_t  load_avg) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 4;
    if (write(fd, &type, 1) != 1) {return -1;}

    u16 = slots; 
    u16 = htonl(u16);
    if ((i = write(fd, &u16, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}

    i = htonl(hostname_len); 
    if ((i = write(fd, &i, 4)) != 4) {return i;} 
    if ((i = write(fd, hostname_data, hostname_len)) != hostname_len) {return i;}

    u32 = mb_free; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}

    u32 = mb_ram; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}

    u32 = load_avg; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    return 0;
}
int hydra_read_CHRESPONSE(int fd,uint32_t *challenge_resp) {
    int i; uint16_t u16; uint32_t u32;

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *challenge_resp = u32;
   return 0;
}
int hydra_write_CHRESPONSE(int fd,uint32_t  challenge_resp) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 1;
    if (write(fd, &type, 1) != 1) {return -1;}

    u32 = challenge_resp; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    return 0;
}
int hydra_read_JOBOK(int fd,uint32_t *jobid) {
    int i; uint16_t u16; uint32_t u32;

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *jobid = u32;
   return 0;
}
int hydra_write_JOBOK(int fd,uint32_t  jobid) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 7;
    if (write(fd, &type, 1) != 1) {return -1;}

    u32 = jobid; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    return 0;
}
int hydra_read_FILEDATA(int fd,uint32_t *jobid) {
    int i; uint16_t u16; uint32_t u32;

    if ((i = read(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    *jobid = u32;
   return 0;
}
int hydra_write_FILEDATA(int fd,uint32_t  jobid) {
    int i; uint16_t u16; uint32_t u32; char type;
    type = 9;
    if (write(fd, &type, 1) != 1) {return -1;}

    u32 = jobid; 
    u32 = htonl(u32);
    if ((i = write(fd, &u32, sizeof(uint32_t))) != sizeof(uint32_t)) {return i;}
    return 0;
}
int hydra_get_next_packettype(int fd) {
    char c;
    if (read(fd, &c, 1) != 1) {
        return -1;
    }
    return c;
}